<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-09-22T08:59:03-04:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">BolunDai0216.github.io</title><entry><title type="html">Tutorial on Building C++ Programs</title><link href="http://localhost:4000/2023/02/26/cpp_building.html" rel="alternate" type="text/html" title="Tutorial on Building C++ Programs" /><published>2023-02-26T00:00:00-05:00</published><updated>2023-02-26T00:00:00-05:00</updated><id>http://localhost:4000/2023/02/26/cpp_building</id><content type="html" xml:base="http://localhost:4000/2023/02/26/cpp_building.html"></content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Notes on Optimization</title><link href="http://localhost:4000/2022/12/02/optimization_notes.html" rel="alternate" type="text/html" title="Notes on Optimization" /><published>2022-12-02T00:00:00-05:00</published><updated>2022-12-02T00:00:00-05:00</updated><id>http://localhost:4000/2022/12/02/optimization_notes</id><content type="html" xml:base="http://localhost:4000/2022/12/02/optimization_notes.html"></content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Feedback Linearization for Double Pendulums</title><link href="http://localhost:4000/2022/06/15/feedback_linearization_db.html" rel="alternate" type="text/html" title="Feedback Linearization for Double Pendulums" /><published>2022-06-15T00:00:00-04:00</published><updated>2022-06-15T00:00:00-04:00</updated><id>http://localhost:4000/2022/06/15/feedback_linearization_db</id><content type="html" xml:base="http://localhost:4000/2022/06/15/feedback_linearization_db.html"></content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Walking Without Thinking About It Notes</title><link href="http://localhost:4000/2022/04/20/walking.html" rel="alternate" type="text/html" title="Walking Without Thinking About It Notes" /><published>2022-04-20T00:00:00-04:00</published><updated>2022-04-20T00:00:00-04:00</updated><id>http://localhost:4000/2022/04/20/walking</id><content type="html" xml:base="http://localhost:4000/2022/04/20/walking.html"></content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Introduction to Rigid Transformations</title><link href="http://localhost:4000/2022/04/20/rigid_transformation.html" rel="alternate" type="text/html" title="Introduction to Rigid Transformations" /><published>2022-04-20T00:00:00-04:00</published><updated>2022-04-20T00:00:00-04:00</updated><id>http://localhost:4000/2022/04/20/rigid_transformation</id><content type="html" xml:base="http://localhost:4000/2022/04/20/rigid_transformation.html">&lt;p&gt;In this blog, I want to talk give a review of rigid transformations, in specific rotation and translation. Although this is the most basic concept in robotics, I tend to confuse many concepts. Therefore, this to me is more like a cheatsheet. The content is developed from &lt;d-cite key=&quot;DBLP:books/daglib/0073732&quot;&gt;&lt;/d-cite&gt;.&lt;/p&gt;

&lt;h2 id=&quot;rigid-transformations&quot;&gt;Rigid Transformations&lt;/h2&gt;

&lt;p&gt;A rigid transformation in \(\mathbb{R}^3\) is a mapping \(g:\mathbb{R}^3\rightarrow\mathbb{R}^3\) that has the following properties:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Length is preserved \(\|g(p) - g(q)\| = \|p - q\|\) for all points \(p, q\in\mathbb{R}^3\).&lt;/li&gt;
  &lt;li&gt;The cross product is preserved \(g_*(v\times w) = g_*(v)\times g_*(w)\) for all vectors \(v, w\in\mathbb{R}^3\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In addition to the above properties we can also prove that the inner product is preserved
\(v_1^Tv_2 = g_*(v_1)^Tg_*(v_2).\)&lt;/p&gt;

&lt;figure class=&quot;l-middle&quot;&gt;
    &lt;img src=&quot;/assets/images/random/rigid_transformation.gif&quot; alt=&quot;rigid transformation illustration&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;We can see from the above animation, that after translation and rotation the length of the two blue lines did not change (\(\|\cdot\|\) did not change), thus satisfying the first property. From the definition of inner product we have&lt;/p&gt;

\[\langle \mathbf{a}, \mathbf{b}\rangle = \|\mathbf{a}\|\|\mathbf{b}\|\cos(\theta)\]

&lt;p&gt;where \(\theta\) is the angle between \(\mathbf{a}\) and \(\mathbf{b}\). We can see that the angle between the two lines did not change (\(\cos(\theta)\) does not change), and since the length is also kept the same, the inner product is preserved. The rotation is in a 2D plane, but we can see that for the body coordinate system before and after the transformation (orange axes) the z-axis is the same, thus the cross product is preserved. This result generalizes to 3D rotations.&lt;/p&gt;

&lt;h2 id=&quot;rotations&quot;&gt;Rotations&lt;/h2&gt;

&lt;h3 id=&quot;properites&quot;&gt;Properites&lt;/h3&gt;

&lt;p&gt;The rotation matrix has the following properties
\(SO(3) = \{R\in\mathbb{R}^{3\times3}\ |\ RR^T = I, \mathrm{det}R = 1\},\)&lt;/p&gt;

&lt;p&gt;where \(SO(3)\) represents the special orthogonal group. Since the rotation matrix is a group under matrix multiplication it has some additional properties:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Closure: If \(R_1, R_2\) are rotation matrices then \(R_1R_2\) is also a rotation matrix.&lt;/li&gt;
  &lt;li&gt;Identity: The identity matrix is the identity element.&lt;/li&gt;
  &lt;li&gt;Inverse: Each rotation matrix has an inverse \(R^{-1} = R^T\).&lt;/li&gt;
  &lt;li&gt;Associativity: For rotation matrices \(R_1, R_2\) and \(R_3\) we have \((R_1R_2)R_3 = R_1(R_2R_3)\).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also rotation matrix is a rigid transformation which means that&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;R preserves length: \(\|Rq - Rp\| = \|p - q\|\) for all points \(p, q\in\mathbb{R}^3\).&lt;/li&gt;
  &lt;li&gt;R preserves orientation: \(R(v\times w) = (Rv)\times(Rw)\) for all vectors \(v, w\in\mathbb{R}^3\).&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;representations&quot;&gt;Representations&lt;/h3&gt;

&lt;figure class=&quot;l-middle&quot;&gt;
    &lt;img src=&quot;/assets/images/random/rotation.gif&quot; alt=&quot;rotation illustration&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;We can see from the animation, that if we have a vector \(\mathbf{q}\) rotating with respect to another vector \(\omega\) with constant angular velocity \(\|\omega\|\), its linear velocity can be calculated as \(\dot{\mathbf{q}} = \omega\times\mathbf{q} = \hat{\omega}\mathbf{q}\). From the knowledge of linear systems (solution of \(\dot{x} = Ax\) is \(x(t) = e^{At}x_0\)) we have the trajectory of the vector as \(\mathbf{q}^\prime = \mathbf{q}(t) = e^{\hat{\omega}t}\mathbf{q}_0\). Additionally, if we have \(\|\omega\| = 1\), then we have \(t = \theta\) the rotation angle.&lt;/p&gt;

&lt;p&gt;From &lt;strong&gt;Euler’s theorem&lt;/strong&gt; we know that for any rotation matrix \(R\in SO(3)\), it can be seen to be equivalent to rotation about a fixed axis \(\omega\in\mathbb{R}^3\) through an angle \(\theta\in[0, 2\pi]\). To represent the rotation matrix this way we can use the exponential map&lt;/p&gt;

\[R = e^{\hat{w}\theta} = I + \frac{\hat{\omega}}{\|\omega\|}\sin{(\|\omega\|\theta)} + \frac{\hat{\omega}^2}{\|\omega\|}\bigg(1 - \cos{((\|\omega\|\theta))}\bigg)\]

&lt;p&gt;where \(\hat{\omega}\) is defined as&lt;/p&gt;

\[\hat{\omega} = \begin{bmatrix}
0 &amp;amp; -\omega_3 &amp;amp; \omega_2\\
\omega_3 &amp;amp; 0 &amp;amp; -\omega_1\\
-\omega_2 &amp;amp; \omega_1 &amp;amp; 0
\end{bmatrix}\in so(3) = \{S\in\mathbb{R}^{3\times3}\ |\ S^T = -S\}.\]

&lt;p&gt;This mapping is many-to-one, which says that there are many \(e^{\hat{w}\theta}\) corresponding to one \(R\), and for every \(R\in SO(3)\) we have more than one \(e^{\hat{w}\theta}\). To obtain \(\omega\) and \(\theta\) from \(R\) we have&lt;/p&gt;

\[\theta = \cos^{-1}\Big(\frac{\mathrm{trace}(R) - 1}{2}\Big)\ \mathrm{and}\ \omega =
\frac{1}{2\sin\theta}\begin{bmatrix}
r_{32} - r_{23}\\
r_{13} - r_{31}\\
r_{21} - r_{12}
\end{bmatrix},\]

&lt;p&gt;we can see that the pair \((\theta, \omega)\) and \((2\pi - \theta, -\omega)\) can both obtain \(R\), thus makes this mapping many-to-one. Note that in the case where \(\theta = 0\) we can pick any arbitrary \(\omega\), which all makes \(R = I\).&lt;/p&gt;

&lt;h3 id=&quot;better-understanding-what-rotation-matrices-represent&quot;&gt;Better understanding what rotation matrices represent&lt;/h3&gt;

&lt;figure class=&quot;l-middle&quot;&gt;
    &lt;img src=&quot;/assets/images/random/twoViewofR.png&quot; alt=&quot;rotation illustration&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Rotation matrices can be seen as a mapping from describing a point in one coordinate frame to describing it in another coordinate frame. For the equation \(x_g^\prime = Rx_b\), we can see \(x_b\) as a point specified in a body frame \(b\) and \(x_g^\prime\) being the same point, however, specified in the coordinates of the global fixed frame \(g\). The rotation matrix \(R\) then serves as a mapping between these two representations.&lt;/p&gt;

&lt;p&gt;Another way to see rotation matrices is to see it as an action, to rotate points in the same frame from one configuration to another. Using the equation \(x_g^\prime = Rx_g\), we can see \(x_g\) as the the point before applying the rotation \(R\) and \(x_g^\prime\) the point after applying rotation \(R\).&lt;/p&gt;

&lt;p&gt;With these two views, we can now better understand how to represent rotations w.r.t the global fixed frame and the body frame. Now we ask, if sequentially applying two rotations \(R_1\) and \(R_2\) both specified in the body frame, where would the point end up in the global frame? Denote \(x_2\) as the final position in the global frame and \(x_0\) the initial position in the global frame, we want to find the rotation matrix between \(x_2\) and \(x_0\). First, we denote the initial position in the global frame as \(x_0^g\), where the superscript \(g\) denotes that this is represented in the global frame. After applying \(R_1\) we have&lt;/p&gt;

\[x_1^g = R_1x_0^g.\]

&lt;p&gt;One thing to note is that in the body frame the coordinates of the point is always the same, which is equal to \(x_0^g\). Thus we have&lt;/p&gt;

\[R_1^Tx_1^g = x_1^{1} = x_0^g,\]

&lt;p&gt;where the superscript 1 denotes the point represented in the body frame after rotation \(R_1\). If we see \(R_1\) as a mapping between points in the frame 1 and the global frame \(g\), we have the following relationship&lt;/p&gt;

\[R_1^Tx^g = x^{1}\ \mathrm{and}\ x^g = R_1x^{1}.\]

&lt;p&gt;Then we can see if we apply \(R_2\) which is w.r.t the frame \(b1\) we can have&lt;/p&gt;

\[x_2^{1} = R_2x_1^{1}\ \rightarrow\ R_2^Tx_2^{1} = x_2^{2} = x_1^{1} = x_0^g,\]

&lt;p&gt;similar to before this utilizes the fact that the coordinates of the point is kept constant in the current body frame. Finally, if we use \(R_1\) to map \(x_2^{1}\) to \(x_2^g\) we can have&lt;/p&gt;

\[R_1x_2^{1} = x_2^g,\]

&lt;p&gt;then we can have&lt;/p&gt;

\[x_2^{g} = R_1R_2x_0{g}.\]

&lt;p&gt;An interesting question would be after we get \(x_2^{g}\) if we rotate about the global frame using \(R_3\) and then rotate about the body frame using \(R_4\) what point will we end up at. If call the point after applying \(R_3\): \(x_3\), we can easily have&lt;/p&gt;

\[x_3^g = R_3x_2^g = R_3R_1R_2x_0^{g} = R_3R_1R_2x_3^{3},\]

&lt;p&gt;which again utilizes the fact that the body frame coordinates do not change \(x_3^{3} = x_2^{2} = x_1^{1} = x_0^g\). Also we obtain a mapping from the global frame and the body frame \(3\): \(x^g = R_3R_1R_2x^3\). Then if we apply \(R_4\), and get to point 4 we can have&lt;/p&gt;

\[x_4^{3} = R_4x_3^{3}\ \rightarrow\ R_4^Tx_4^{3} = x_3^{3} = x_4^{4} = x_0^g.\]

&lt;p&gt;To map \(x_4^{3}\) into the global frame we can have&lt;/p&gt;

\[R_3R_1R_2x_4^{3} = R_3R_1R_2R_4x_4^{4} = x_4^g\ \rightarrow\ R_4^TR_2^TR_1^TR_3^Tx_4^g = x_0^g\ \rightarrow\ x_4^g = R_3R_1R_2R_4x_0^g.\]

&lt;p&gt;Following this line of thought, I conjecture that we can completely decouple the rotations about the global frame and the body frame. I am pretty sure this is proved and shown somewhere, if anyone reading this has any information please let me know.&lt;/p&gt;

&lt;h2 id=&quot;rigid-motions-in-3d&quot;&gt;Rigid Motions in 3D&lt;/h2&gt;

&lt;p&gt;In this section I will talk about rigid motions which includes both translation and rotation. I will present three ways of describing such a motion, namely, homogeneous transformation, twist and screw motions, and we will see how these three descriptions are related.&lt;/p&gt;

&lt;h3 id=&quot;homogeneous-representations&quot;&gt;Homogeneous Representations&lt;/h3&gt;

&lt;p&gt;Any rigid motion can be represented by a translation \(p\) and a rotation \(R\). If we perform such a transformation \(g(\cdot)\), we can relate the position before and after the transformation as&lt;/p&gt;

\[q^\prime = g(q) = p + Rq.\]

&lt;p&gt;And for a vector \(v\) we have \(g_*(v) = Rv\). This forms the special Euclidean group&lt;/p&gt;

\[SE(3) = \{(p, R)\ |\ p\in\mathbb{R}^3, R\in SO(3)\} = \mathbb{R}^3\times SO(3).\]

&lt;p&gt;As before we can see this from two ways. If \(g(\cdot)\) is seen as an action then both \(q^\prime\) and \(q\) are measured in the same coordinate frame. If we see this as a mapping between frames, then \(q^\prime\) and \(q\) are measured in different frames. Later I will consolidate this using an example. Before that, I want to introduce the homogeneous representation of points and vectors. For a point \(p\) and vector \(v\) we can have their homogeneous representation as
\(\bar{p} = \begin{bmatrix}
p_1\\
p_2\\
p_3\\
1
\end{bmatrix},\ \bar{v} = \begin{bmatrix}
v_1\\
v_2\\
v_3\\
0
\end{bmatrix},\)&lt;/p&gt;

&lt;p&gt;here I would like to draw your attention to the last element, for points the last element is \(1\) and for vectors the last element is \(0\). The we can homogeneous representation of \(SE(3)\) as&lt;/p&gt;

\[\bar{g} = \begin{bmatrix}
R &amp;amp; p\\
\mathbf{0} &amp;amp; 1
\end{bmatrix}.\]

&lt;p&gt;It is proved that \(SE(3)\) is a group, therefore, it satisfies the following properties&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;If \(g_1, g_2\in SE(3)\), then \(g_1g_2\in SE(3)\).&lt;/li&gt;
  &lt;li&gt;It has an identity element which is \(I_{4\times4}\).&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;There exists an inverse for \(g = (p, R)\in SE(3)\), defined as
\(g^{-1} = (-R^Tp, R^T)\ \rightarrow\ \bar{g}^{-1} = \begin{bmatrix}
  R^T &amp;amp; -R^Tp\\
  \mathbf{0} &amp;amp; 1
  \end{bmatrix}.\)&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;The composition rule
\(\bar{g}_{ac} = \bar{g}_{ab}\bar{g}_{bc} = \begin{bmatrix}
  R_{ab}R_{bc} &amp;amp; R_{ab}p_{bc} + p_{ab}\\
  \mathbf{0} &amp;amp; 1
  \end{bmatrix}\)
is associative.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Also we can prove that is a rigid transformation, which infers&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;\(g\) preserves distance between points \(\|g(p) - g(q)\| = \|p - q\|\), for all \(p, q\in\mathbb{R}^3\).&lt;/li&gt;
  &lt;li&gt;\(g\) preserves orientation between vectors \(g_*(v\times w) = g_*(v)\times g_*(w)\), for all \(v, w\in\mathbb{R}^3\).&lt;/li&gt;
&lt;/ul&gt;

&lt;figure class=&quot;l-middle&quot;&gt;
    &lt;img src=&quot;/assets/images/random/twoViewofg.png&quot; alt=&quot;rotation illustration&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Now I want to use an example to better understand the two views of this homogeneous representation. Consider rotating \(\theta\) about the vertical line going though point \((l_x, l_y, 0)\), how can we find the transformation \(g_{ab}\) such that \(x_g\) is the position of the point before and \(x_g^\prime\) is the position after, which are all represented in the global fixed frame. We can see this as two steps, a rotation \(R\) and a translation \(p\), the rotation is w.r.t the vertical line \((0, 0, 0)\) and the translation is from \((0, 0, 0)\) to \((l_x, l_y, 0)\). Denoting a point \(x\) with the coordinates in the body frame (light purple frame above) as \(x_b\), we define&lt;/p&gt;

\[x_b^1 = Rx_b.\]

&lt;p&gt;And after the translation we have&lt;/p&gt;

\[x_g^\prime = x_b^1 + p = Rx_b + p.\]

&lt;p&gt;Therefore we have&lt;/p&gt;

\[x_g^\prime = p + Rx_b\ \rightarrow\ \bar{g} = \begin{bmatrix}
R &amp;amp; p\\
0 &amp;amp; 1
\end{bmatrix} = \begin{bmatrix}
\cos\theta &amp;amp; -\sin\theta &amp;amp; 0 &amp;amp; l_x\\
\sin\theta &amp;amp; \cos\theta &amp;amp; 0 &amp;amp; l_y\\
0 &amp;amp; 0 &amp;amp; 1 &amp;amp; 0\\
0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1
\end{bmatrix}.\]

&lt;p&gt;Also if we start at point \(x_g = x_b\), where \(x_g\) is measured in the global frame, this gives you a way to calculate the position after applying \(R\) and \(p\)&lt;/p&gt;

\[x_g^\prime = p + Rx_g.\]

&lt;h3 id=&quot;twists&quot;&gt;Twists&lt;/h3&gt;

&lt;p&gt;In the previous sections, we talked about how to rotate rigid bodies, however, all of them were rotating about an axis that passes through the global fixed frame, in this part in addition to introducing a more compact way of representing rigid body motion, I will also talk about how to rotate about axis that do not pass through the origin of the fixed frame. In the homogeneous coordinates we can write the pure rotation with unit velocity about axis \(\omega\in\mathbb{R}^3\)&lt;/p&gt;

&lt;p&gt;\(\dot{p}(t) = \omega\times(p(t) - q)\)
as
\(\begin{bmatrix}
\dot{p}\\
1
\end{bmatrix} = \begin{bmatrix}
\hat{\omega} &amp;amp; -\omega\times q\\
0 &amp;amp; 1
\end{bmatrix}\begin{bmatrix}
p\\
1
\end{bmatrix} = \hat{\xi}\begin{bmatrix}
p\\
1
\end{bmatrix}\ \longleftrightarrow \dot{\bar{p}} = \hat{\xi}\bar{p}.\)&lt;/p&gt;

&lt;p&gt;Thus the solution \(\bar{p}(t) = \exp{(\hat{\xi}t)}\bar{p}(0)\) enables a mapping from the initial location to the location after \(t\) radians of rotation \(\exp{(\hat{\xi}t)}\). Note that here \(q\) is a point on the axis \(\omega\) given in the global coordinates. For pure translations we have&lt;/p&gt;

\[\hat{\xi} = \begin{bmatrix}
0 &amp;amp; v\\
0 &amp;amp; 0
\end{bmatrix}\]

&lt;p&gt;where \(v\) is a vector representing the translation velocity. We define twists as the group&lt;/p&gt;

\[\hat{\xi} \in se(3) := \{(v, \hat{\omega})\ |\ v\in\mathbb{R}^3, \hat{\omega}\in so(3)\} =
\begin{bmatrix}
\hat{\omega} &amp;amp; v\\
0 &amp;amp; 1
\end{bmatrix}\in\mathbb{R}^{4\times4},\]

&lt;p&gt;with the twist coordinates \(\xi := (v,\ \omega)\). We can prove that for every member of \(se(3)\) we can find its corresponding element in \(SE(3)\) using an exponential mapping&lt;/p&gt;

\[\begin{align*}
e^{\hat{\xi}\theta} &amp;amp;= \begin{bmatrix}
I &amp;amp; v\theta\\
0 &amp;amp; 1
\end{bmatrix} &amp;amp; \omega = 0\\
e^{\hat{\xi}\theta} &amp;amp;= \begin{bmatrix}
e^{\hat{\omega}\theta} &amp;amp; (I - e^{\hat{\omega}\theta})(\omega\times v) +
\omega\omega^Tv\theta\\
0 &amp;amp; 1
\end{bmatrix} &amp;amp; \omega \neq 0.
\end{align*}\]

&lt;p&gt;Also for every \(p, R\) we can find its corresponding twist \(\hat{\xi}\in se(3)\) and \(\theta\in\mathbb{R}\), for \(R = I\) we have&lt;/p&gt;

\[\begin{align*}
\hat{\xi} &amp;amp;= \begin{bmatrix}
0 &amp;amp; p/\|p\|\\
0 &amp;amp; 0
\end{bmatrix} &amp;amp;\theta = \|p\|.
\end{align*}\]

&lt;p&gt;If \(R \neq I\), then first we can solve for \(\hat{w}\) and \(\theta\) by solving \(e^{\hat{\omega}\theta} = R\), which was mentioned above. Then we can solve for \(v\)&lt;/p&gt;

\[v = \Big[(I - e^{\hat{\omega}\theta})\hat{\omega} + \omega\omega^T\theta\Big]^{-1}p.\]

&lt;p&gt;Note, here if we write \(p(\theta) = \exp{(\hat{\xi}\theta)}p(0)\), then \(p(\theta)\) and \(p(0)\) are specified in the same reference frame. If we want to specify \(p(0)\) in the body frame then we have&lt;/p&gt;

\[p(\theta) = \exp{(\hat{\xi}\theta)}g_{gb}(0)p^b(0)\]

&lt;p&gt;where \(g_{gb}\) gives the mapping between coordinates in the body and the global frame at \(t = 0\).&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Twist&lt;/th&gt;
      &lt;th&gt;Linear System&lt;/th&gt;
      &lt;th&gt;Comments&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;\(\dot{p}(t) = \omega\times(p(t) - q)\)&lt;/td&gt;
      &lt;td&gt;\(\dot{x}(t) = \omega(x(t) - O)\)&lt;/td&gt;
      &lt;td&gt;\(\xi = \begin{bmatrix}-\omega\times q\\ \omega\end{bmatrix} = \begin{bmatrix}v\\ \omega\end{bmatrix}\), differential equations governing the movement&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\(\dot{\bar{p}} = \hat{\xi}\bar{p}\)&lt;/td&gt;
      &lt;td&gt;\(\dot{x} = Ax\)&lt;/td&gt;
      &lt;td&gt;\(\hat{\xi} = \begin{bmatrix}\hat{\omega} &amp;amp; -\omega\times q\\ 0 &amp;amp; 1\end{bmatrix}\), differential equation in vector form&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;\(\bar{p}(t) = \exp{(\hat{\xi}t)}\bar{p}(0)\)&lt;/td&gt;
      &lt;td&gt;\(x(t) = \exp{(At)}x(0)\)&lt;/td&gt;
      &lt;td&gt;\(\exp{(\hat{\xi}t)} = \begin{bmatrix}e^{\hat{\omega}\theta} &amp;amp; (I - e^{\hat{\omega}\theta})(\omega\times v) + \omega\omega^Tv\theta\\ 0 &amp;amp; 1\end{bmatrix}\), analytic solution to differential equation.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;screw-motion&quot;&gt;Screw Motion&lt;/h3&gt;

&lt;p&gt;Here we state &lt;strong&gt;Chasles’ Theorem&lt;/strong&gt;: every rigid body motion can be realized by a rotation about an axis \(\omega\) combined with a translation parallel to that axis. We assume that the rotation is of \(\theta\) radians and the translation is of amount \(d\), also we can find a point on \(\omega\) and call it \(q\).&lt;/p&gt;

&lt;p&gt;We can see that this movement resembles the movement of a screw. We can describe the screw movement using: &lt;em&gt;pitch&lt;/em&gt; as \(h:=d/\theta\), the &lt;em&gt;axis&lt;/em&gt; of the screw movement as&lt;/p&gt;

\[l = \{q + \lambda\omega\ |\ \lambda\in\mathbb{R}\}\]

&lt;p&gt;and a &lt;em&gt;magnitude&lt;/em&gt; \(M = \theta\) when there is rotation and \(M = \infty\) when there is only translation.&lt;/p&gt;

&lt;p&gt;For a given screw motion we can find its rigid transfomation as&lt;/p&gt;

\[\begin{align*}
g &amp;amp;= \begin{bmatrix}
e^{\hat{\omega}\theta} &amp;amp; (I - e^{\hat{\omega}\theta})q + h\theta\omega\\
0 &amp;amp; 1
\end{bmatrix} &amp;amp; \mathrm{with\ rotation}\\
g &amp;amp;= \begin{bmatrix}
I &amp;amp; \theta v\\
0 &amp;amp; 1
\end{bmatrix} &amp;amp; \mathrm{pure\ translation}
\end{align*}\]

&lt;p&gt;where \(v\) is the vector of translation. Additionally, when given a twist we can also find its corresponding screw, and given a screw we can find its corresponding twist.&lt;/p&gt;

&lt;h2 id=&quot;velocity-of-a-rigid-body&quot;&gt;Velocity of a Rigid Body&lt;/h2&gt;

&lt;h3 id=&quot;rotational-velocity&quot;&gt;Rotational Velocity&lt;/h3&gt;

&lt;p&gt;First we define the spatial coordinate frame \(A\) which is fixed and the body coordinate frame \(B\) which is moving. If we define a point \(q_b\) in the body frame, and a rotation motion \(R_{ab}(t)\), then we can have the trajectory of the point in spatial coordinates as&lt;/p&gt;

\[q_a(t) = R_{ab}(t)q_b.\]

&lt;p&gt;By deriving that both \(R^{-1}\dot{R}\) and \(\dot{R}R^{-1}\) are skew symmetric matrices, we can get the angular velocity in both the spatial coordinate \(\hat{\omega}^s\) and the instantaneous body coordinate \(\hat{\omega}^b\) (since the body coordinate is changing due to rotation)&lt;/p&gt;

\[v_{q_a}(t) = \dot{R}_{ab}(t)q_b =
\underbrace{\dot{R}_{ab}(t)R_{ab}^{-1}(t)}_{:=\ \hat{\omega}_{ab}^s}R_{ab}(t)q_b =
\hat{\omega}_{ab}^sR_{ab}(t)q_b = \hat{\omega}_{ab}q_a.\]

&lt;p&gt;The instantaneous body angluar velocity is defined as seeing the spatial angular velocity vector in the body frame,&lt;/p&gt;

\[v_{q_b}(t) := R_{ab}^Tv_{q_a}(t)\ \ \ \ \hat{\omega}_{ab}^b = R_{ab}^{-1}\dot{R}_{ab}\]

&lt;p&gt;which is not the angluar velocity of the rigid body w.r.t the body frame, the latter is always zero.&lt;/p&gt;

&lt;h3 id=&quot;rigid-body-velocity&quot;&gt;Rigid Body Velocity&lt;/h3&gt;

&lt;p&gt;For a rigid motion plan \(g_{ab}(t)\in SE(3)\) we can get the spatial velocity as a twist \(\hat{V}_{ab}^s\in se(3)\)&lt;/p&gt;

\[\hat{V}_{ab}^s = \dot{g}_{ab}g_{ab}^{-1}\ \ \ \ V_{ab}^s = \begin{bmatrix}
v_{ab}^s\\
\omega_{ab}^s
\end{bmatrix} = \begin{bmatrix}
-\dot{R}_{ab}R_{ab}^Tp_{ab} + \dot{p}_{ab}\\
(\dot{R}_{ab}R_{ab}^T)^\vee
\end{bmatrix}\]

&lt;p&gt;Thus the velocity of a point \(q_a\) can be found as&lt;/p&gt;

\[v_{q_a} = \hat{V}_{ab}^sq_a = \omega_{ab}^s\times q_a + v_{ab}^s.\]

&lt;p&gt;Here we can interpret \(\omega_{ab}^s\) as the instantaneous angular velocity of the body as viewed in the spatial frame and \(v_{ab}^s\) as the velocity of a (possibly imaginary) point on the rigid body which is traveling through the origin of the spatial frame at time \(t\). The body velocity is defined as&lt;/p&gt;

\[\hat{V}_{ab}^b = g_{ab}^{-1}\dot{g}_{ab}\ \ \ \ V_{ab}^b = \begin{bmatrix}
v_{ab}^b\\
\omega_{ab}^b
\end{bmatrix} = \begin{bmatrix}
R_{ab}^T\dot{p}_{ab}\\
(R_{ab}^T\dot{R}_{ab})^\vee
\end{bmatrix}\]

&lt;p&gt;which for \(v_{ab}^b\) can be interpretted as the velocity of the origin of the body coordinate frame relative to the spatial frame, as viewed in the current body frame; for \(\omega_{ab}^b\) we can see it as the angular velocity of the coordinate frame, also as viewed in the current body frame. We can also define an adjoint transformation to relate the spatial and body velcoties&lt;/p&gt;

\[V_{ab}^s = \begin{bmatrix}
v_{ab}^s\\
\omega_{ab}^s
\end{bmatrix} = \begin{bmatrix}
R_{ab} &amp;amp; \hat{p}_{ab}R_{ab}\\
0 &amp;amp; R_{ab}
\omega_{ab}^b
\end{bmatrix}\begin{bmatrix}
v_{ab}^b\\
\omega_{ab}^b
\end{bmatrix} = Ad_{g}V_{ab}^b.\]

&lt;h3 id=&quot;coordinate-transformation&quot;&gt;Coordinate Transformation&lt;/h3&gt;

&lt;p&gt;For three coordinate frames A, B and C, we can have the relationship between their spatial velocity as&lt;/p&gt;

\[V_{ac}^s = V_{ab}^s + Ad_{g_{ab}}V_{bc}^s\]

&lt;p&gt;similarly we can get the relationship between their body velocities as&lt;/p&gt;

\[V_{ac}^b = Ad_{g_{bc}^{-1}}V_{ab}^b + V_{bc}^b.\]

&lt;p&gt;This relationship can also be used to represent twists before and after applying a rigid motion&lt;/p&gt;

\[\xi^\prime = Ad_g\xi\ \ \mathrm{or}\ \ \hat{\xi}^\prime = g\hat{\xi}g^{-1}.\]

&lt;p&gt;Some additional properties include&lt;/p&gt;

\[\begin{align*}
V_{ab}^{b} &amp;amp;= V_{ba}^{s}\\
V_{ab}^{b} &amp;amp;= -Ad_{g_{ba}}V_{ba}^{b}
\end{align*}\]

&lt;h2 id=&quot;wrenches&quot;&gt;Wrenches&lt;/h2&gt;

&lt;p&gt;A wrench is defined as a force/moment pair \(F\in\mathbb{R}^6\)&lt;/p&gt;

\[F = \begin{bmatrix}
f\\
\tau
\end{bmatrix}.\]

&lt;p&gt;Given its dual nature with twist we have the relationship mapping wrenches between different coordinates systems as&lt;/p&gt;

\[F_c = Ad_{g_{bc}}^TF_b.\]

&lt;p&gt;And for the same wrench the instantaneous work is the same in both the spatial and body frame&lt;/p&gt;

\[\delta W = V^b\cdot F^b = V^s\cdot F^s,\]

&lt;p&gt;note that here \(\cdot\) represents the dot product.&lt;/p&gt;

&lt;p&gt;Using &lt;strong&gt;Poinsot&lt;/strong&gt;’s Theorem we can see every collection of wrenches applied to a rigid body is equivalent to a force applied along a fixed axis plus a torque about the same axis. Thus there exists a direct mapping between wrenches and screw motions.&lt;/p&gt;

&lt;d-byline&gt;&lt;/d-byline&gt;

&lt;p class=&quot;citation&quot;&gt;
    Powered by &lt;a href=&quot;https://www.mathjax.org&quot;&gt;
    &lt;img title=&quot;Powered by MathJax&quot; src=&quot;https://www.mathjax.org/badge/mj_logo.png&quot; style=&quot;border:0;&quot; alt=&quot;Powered by MathJax&quot; /&gt;
    &lt;/a&gt;
&lt;/p&gt;</content><author><name></name></author><summary type="html">In this blog, I want to talk give a review of rigid transformations, in specific rotation and translation. Although this is the most basic concept in robotics, I tend to confuse many concepts. Therefore, this to me is more like a cheatsheet. The content is developed from .</summary></entry><entry><title type="html">PyMuJoCoBase</title><link href="http://localhost:4000/2022/04/20/pymujocobase.html" rel="alternate" type="text/html" title="PyMuJoCoBase" /><published>2022-04-20T00:00:00-04:00</published><updated>2022-04-20T00:00:00-04:00</updated><id>http://localhost:4000/2022/04/20/pymujocobase</id><content type="html" xml:base="http://localhost:4000/2022/04/20/pymujocobase.html"></content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Modular &amp;amp; Minimal PyTorch Implementation of Proximal Policy Optimization</title><link href="http://localhost:4000/2022/04/20/ppo_torch.html" rel="alternate" type="text/html" title="Modular &amp;amp; Minimal PyTorch Implementation of Proximal Policy Optimization" /><published>2022-04-20T00:00:00-04:00</published><updated>2022-04-20T00:00:00-04:00</updated><id>http://localhost:4000/2022/04/20/ppo_torch</id><content type="html" xml:base="http://localhost:4000/2022/04/20/ppo_torch.html"></content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Cart-pole Swing-up Task Using MPC</title><link href="http://localhost:4000/2022/04/20/cp_swingup_mpc.html" rel="alternate" type="text/html" title="Cart-pole Swing-up Task Using MPC" /><published>2022-04-20T00:00:00-04:00</published><updated>2022-04-20T00:00:00-04:00</updated><id>http://localhost:4000/2022/04/20/cp_swingup_mpc</id><content type="html" xml:base="http://localhost:4000/2022/04/20/cp_swingup_mpc.html">&lt;p&gt;In this blog, I want to swing-up a cart-pole system using a model predictive control (MPC) based method. When I was initially shown this problem, I thought this was a toy problem and I will be able to solve in a few minutes. Then I realized that in school, all I have been taught was about linear MPC, and for cartpole related problems all I know is how to balance it on the top, assuming that it starting close to the top, so that the linearization is still valid. As for the case of swinging-up the cartpole, this stems firmly in the realm of nonlinear control. Which I have also learned. One of the more classical ways to deal with this would then be to linearize along the trajectory, such as using iLQR. However, when given state and control constraints, e.g. limit control effort and not letting the cartpole sway to far, iLQR losses its appeal. There are ways to incorporate constraints into iLQR, such as&lt;d-cite key=&quot;DBLP:conf/iros/HowellJM19&quot;&gt;&lt;/d-cite&gt;, which seems like an overkill for such a simple problem.&lt;/p&gt;

&lt;p&gt;I then did some reading and I found a way to do constrained nonlinear control: using direct collocation&lt;d-cite key=&quot;DBLP:journals/siamrev/Kelly17&quot;&gt;&lt;/d-cite&gt;. By tweaking the formulation a bit I was able to find a way to perform a trapezoidal-collocation-based-MPC to swing-up a cartpole system and that is what I will be presenting in this blog.&lt;/p&gt;

&lt;h2 id=&quot;introduction&quot;&gt;Introduction&lt;/h2&gt;

&lt;p&gt;Now let’s first define the system and the problem. The dynamics of the cart-pole system can be defined as&lt;/p&gt;

\[\dot{\mathbf{x}} = \begin{bmatrix}
\dot{x}\\
\dot{\theta}\\
\ddot{x}\\
\ddot{\theta}
\end{bmatrix} = \begin{bmatrix}
\dot{x}\\
\dot{\theta}\\
\frac{m_p\sin{\theta}(l\dot{\theta}^2 + g\cos{\theta})}{m_c + m_p\sin^2{\theta}}\\
\frac{-m_pl\dot{\theta}^2\cos{\theta}\sin{\theta} - (m_c + m_p)g\sin{\theta}}{l(m_c +
m_p\sin^2{\theta})}
\end{bmatrix} + \begin{bmatrix}
0\\
0\\
\frac{1}{m_c + m_p\sin^2{\theta}}\\
\frac{-1}{l(m_c + m_p\sin^2{\theta})}
\end{bmatrix}u,\]

&lt;p&gt;where \(m_c\) is the weight of the cart, \(m_p\) is the weight of the pole, \(\ell\) is the length of the pole, \(x\) is the center of mass position of the cart, \(\theta\) is the orientation of the pole and \(u\) is the control action which in this case is a force acting on the cart. The control problem is to swing-up the pole till it balances at the upright position. This can be captured using the following cost function&lt;/p&gt;

\[J = \int_{0}^{T}{(\mathbf{x}(t) - x^*)^TQ(\mathbf{x}(t) - x^*) + u(t)^TRu(t)dt},\]

&lt;p&gt;where \(Q\) and \(R\) are weight matrices, \(T\) is the preview horizon and \(x^*\) is the target state, which in this case is \([1,\ \pi,\ 0,\ 0]^T\). To make the problem more realistic, the cart position and control efforts are all constrained, i.e. \(x\in[-a,\ a]\) and \(u\in[-b,\ b]\). This problem is a nonlinear constrained optimization problem which is quite hard to solve, if written as-is I don’t even know how to give it to a solver (if anyone reading this has a solution please let me know). In the next section, we will look into how using a trapezoidal collocation method we can transform the problem into something more tractable.&lt;/p&gt;

&lt;h2 id=&quot;trapezoidal-collocation&quot;&gt;Trapezoidal Collocation&lt;/h2&gt;

&lt;p&gt;The key idea here is to approximate integrals using trapezoidal quadrature. There are other ways to approximate it, as mentioned in&lt;d-cite key=&quot;DBLP:journals/siamrev/Kelly17&quot;&gt;&amp;lt;/dt-cite&amp;gt;, however, given its simplicity we will focus on the trapezoidal approximation. Like any other idea, to understand the concept all you need is the right image.&lt;/d-cite&gt;&lt;/p&gt;

&lt;figure class=&quot;l-page&quot;&gt;
    &lt;img src=&quot;/assets/images/control_theory/trapezoidal.png&quot; alt=&quot;trapezoidal quadrature&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Here we can use the system dynamics \(\dot{x} = f(x)\) as an example. If we want to integrate the system dynamics from \(t_k\) to \(t_{k+1}\),&lt;/p&gt;

\[\int_{t_k}^{t_{k+1}}{\dot{x}} = \int_{t_k}^{t_{k+1}}{f(x)},\]

&lt;p&gt;is equivalent to calculating the area under the curve \(f(x)\) from \(t_k\) to \(t_{k+1}\). Which we can easily see can be approximated by a trapezoidal quadrature denoted by the yellow region. Using the formula of trapezoidal area we can get an approximation of the system dynamics&lt;/p&gt;

\[\int_{t_k}^{t_{k+1}}{\dot{x}} = \frac{t_{k+1} - t_k}{2}\Big(f(x(t_k)) + f(x(t_{k+1}))\Big) \approx x(t_{k+1}) - x(t_k),\]

&lt;p&gt;where the last approximation is obtained by the fundamental theorem of calculus. By discretizing the system dynamics and cost function using a trapezoidal approximation we can easily write out the aforementioned nonlinear constrained optimization problem, which we will discuss in the next section.&lt;/p&gt;

&lt;h2 id=&quot;reformulation&quot;&gt;Reformulation&lt;/h2&gt;

&lt;p&gt;Using the aforementioned trapezoidal approximation, we can transform the cost from an integration over the entire trajectory to a summation at a few states, which are called knot points. The step-wise cost is&lt;/p&gt;

\[w(t) = (\mathbf{x}(t) - x^*)^TQ(\mathbf{x}(t) - x^*) + u(t)^TRu(t).\]

&lt;p&gt;If we take the integral between \(t_k\) and \(t_{k+1}\) we have&lt;/p&gt;

\[\int_{t_k}^{t_{k+1}}{w(t)dt} \approx \frac{t_{k+1} - t_k}{2}\Big(w(t_k) + w(t_{k+1})\Big).\]

&lt;p&gt;If we pick a series of timesteps \(h_k = t_{k+1} - t_k\), for the entire preview horizon we can have&lt;/p&gt;

\[\int_{0}^{T}{w(t)dt} = \sum_{i=0}^{N-1}{\frac{h_k}{2}\Big(w(t_k) + w(t_{k+1})\Big)}.\]

&lt;p&gt;Similarly, to ensure the state dynamics are respected, an equality constraint needs to be added. Following the same formulation as the last section we have a set of equality constraints, one at each knot point,&lt;/p&gt;

\[\frac{h_k}{2}\Big(f(x(t_k)) + f(x(t_{k+1}))\Big) = x(t_{k+1}) - x(t_k), \forall i = 1, \cdots, N-1.\]

&lt;p&gt;Now we can write out the reformulated problem&lt;/p&gt;

\[\begin{align*}
\min_{x(\cdot), u(\cdot)}\ &amp;amp;\ \sum_{i=0}^{N-1}{\frac{h_k}{2}\Big(w(t_k) + w(t_{k+1})\Big)}\\
s.t.\ &amp;amp;\ \frac{h_k}{2}\Big(f(x(t_k)) + f(x(t_{k+1}))\Big) =
x(t_{k+1}) - x(t_k)\\
&amp;amp;\ -\mathbf{a} \leq x(t_k) \leq \mathbf{a}\\
&amp;amp;\ -b \leq u(t_k) \leq b.\\
&amp;amp;\ x_0 = 0, \forall i = 1, \cdots, N-1.
\end{align*}\]

&lt;p&gt;For the original direct collocation approach, the cost is only the control squared and there is an additional terminal state constraint. However, in a MPC framework, this approach is too “fragmented”. Intuitively, one can think that under such a setup, in order the minimize the cost, it would be best to plan to only reach the top at the end of the preview horizon. Since in MPC the preview horizon is moving, this will make the system never attempt to actually reach the target, but always “preparing” to.&lt;/p&gt;

&lt;h2 id=&quot;results&quot;&gt;Results&lt;/h2&gt;

&lt;figure class=&quot;l-page&quot;&gt;
    &lt;img src=&quot;/assets/images/control_theory/cartpole_solution.png&quot; alt=&quot;cartpole solution&quot; /&gt;
&lt;/figure&gt;

&lt;p&gt;Using the aforementioned approach we can see that the cart-pole system is able to balance at the top. The control is saturated at 10N. The target is \([1.0,\ \pi,\ 0.0,\ 0.0]\). Though not shown here, the simulation is ran for 10 seconds and the pole is firmly balanced at the top. We see that this approach truly is able to solve the cartpole swing-up task. One thing to note is that when running SQP there is no need to run till a solution is found, in this case only four iteration is allowed at each timestep.&lt;/p&gt;

&lt;p&gt;A few notes on the implementation. I implemented this in Matlab, due to not being able to get scipy’s optimization package to work, while fmincon works right out the box, credit to Mathworks. If anyone is able to get this working on scipy please let me know, I am dying to know what I did wrong. To ensure the system dynamics are as close to reality as possible, it was integrated using ode45. This shows that even if the dynamics are simplified when using trapezoidal collocation, the resulting control is still adequate in dealing with real dynamics.&lt;/p&gt;

&lt;d-byline&gt;&lt;/d-byline&gt;

&lt;p class=&quot;citation&quot;&gt;
    Powered by &lt;a href=&quot;https://www.mathjax.org&quot;&gt;
    &lt;img title=&quot;Powered by MathJax&quot; src=&quot;https://www.mathjax.org/badge/mj_logo.png&quot; style=&quot;border:0;&quot; alt=&quot;Powered by MathJax&quot; /&gt;
    &lt;/a&gt;
&lt;/p&gt;</content><author><name></name></author><summary type="html">In this blog, I want to swing-up a cart-pole system using a model predictive control (MPC) based method. When I was initially shown this problem, I thought this was a toy problem and I will be able to solve in a few minutes. Then I realized that in school, all I have been taught was about linear MPC, and for cartpole related problems all I know is how to balance it on the top, assuming that it starting close to the top, so that the linearization is still valid. As for the case of swinging-up the cartpole, this stems firmly in the realm of nonlinear control. Which I have also learned. One of the more classical ways to deal with this would then be to linearize along the trajectory, such as using iLQR. However, when given state and control constraints, e.g. limit control effort and not letting the cartpole sway to far, iLQR losses its appeal. There are ways to incorporate constraints into iLQR, such as, which seems like an overkill for such a simple problem.</summary></entry><entry><title type="html">An Introduction to Control Barrier Functions</title><link href="http://localhost:4000/2022/04/20/cbf.html" rel="alternate" type="text/html" title="An Introduction to Control Barrier Functions" /><published>2022-04-20T00:00:00-04:00</published><updated>2022-04-20T00:00:00-04:00</updated><id>http://localhost:4000/2022/04/20/cbf</id><content type="html" xml:base="http://localhost:4000/2022/04/20/cbf.html"></content><author><name></name></author><summary type="html"></summary></entry><entry><title type="html">Linear Time Invariant Systems</title><link href="http://localhost:4000/2022/01/01/lti.html" rel="alternate" type="text/html" title="Linear Time Invariant Systems" /><published>2022-01-01T00:00:00-05:00</published><updated>2022-01-01T00:00:00-05:00</updated><id>http://localhost:4000/2022/01/01/lti</id><content type="html" xml:base="http://localhost:4000/2022/01/01/lti.html">&lt;p&gt;To understand control theory we need a medium. We can see how different motor torques effect the walking motion of a biped robot but the correlation would be convoluted for a beginner. The default choice of such a medium for control theory noobs is a linear time invariant (LTI) system. The next question would be what makes LTI systems special? Let’s start with some of its properties. A LTI system has three main properties: homogeneity, additivity (or commonly known as superposition) and as the name suggests time invariance. One may ask I see the time invariance, where is the linear? The “linear” part is constructed by the homogeneity and additivity. In the following sections we  will look into these three properties.&lt;/p&gt;

&lt;p&gt;First, let’s take a look at homogeneity. What this means is that for a LTI system, if the output of the system is \(y(t)\) when given input \(x(t)\), then the output will be \(ay(t)\) when the input is \(ax(t)\). For example, if I weight \(70kg\) the scale will show that I weight \(70kg\), if I weight \(2\times70 = 140kg\) the scale will show that I weight \(2\times70 = 140kg\).&lt;/p&gt;

&lt;p&gt;Then, let’s talk about additivity. What this means if that for a LTI system, if the system outputs \(y_1(t)\) when given input \(x_1(t)\) and outputs \(y_2(t)\) when given input \(x_2(t)\), when given input \(x_1(t) + x_2(t)\) it will output \(y_1(t) + y_2(t)\). Also using the scale example, if two people of weight \(70kg\) each stand on the scale at the same time the scale will show \(70 + 70 = 140kg\).&lt;/p&gt;

&lt;p&gt;Finally, for time invariance it means that if the output of the system is \(y(t)\) when given input \(x(t)\), the output will be \(y(t-a)\) when given input \(x(t-a)\). Using the scale example, if I maintained the same weight of \(70kg\) throughout the day, the scale will show \(70kg\) no matter if its in the morning or \(11\)pm.&lt;/p&gt;

&lt;p&gt;For a system that is subject to an unit impulse \(\delta(t)\) we can have its output as \(y(t)\). If the system is subject to three impulses \(\delta(t)\), \(2\delta(t-1)\) and \(3\delta(t-2)\), using the properties of a LTI system we can say the output at time \(t\) will be&lt;/p&gt;

\[\mathrm{output}(t) = y(t) + 2y(t-1) + 3y(t-2).\]

&lt;p&gt;For a continuous input signal \(x(t)\) we can see it as applying the impulse \(x(a)\delta(t-a)\) at time \(t = a\). Then also using the properties of a LTI system we have&lt;/p&gt;

\[\mathrm{output}(t) = \int_{-\infty}^{\infty}x(a)y(t-a)da\]

&lt;p&gt;with \(x(a) = 0\) for \(a \leq 0\) and \(y(t-a) = 0\) for \(a \geq 0\). This is for accounting for the control signal to be \(0\) for all negative time, and the output to be \(0\) for all negative time. This operation is called a convolution and usually denotes as \(x*y\).&lt;/p&gt;

&lt;d-byline&gt;&lt;/d-byline&gt;

&lt;p class=&quot;citation&quot;&gt;
    Powered by &lt;a href=&quot;https://www.mathjax.org&quot;&gt;
    &lt;img title=&quot;Powered by MathJax&quot; src=&quot;https://www.mathjax.org/badge/mj_logo.png&quot; style=&quot;border:0;&quot; alt=&quot;Powered by MathJax&quot; /&gt;
    &lt;/a&gt;
&lt;/p&gt;</content><author><name></name></author><summary type="html">To understand control theory we need a medium. We can see how different motor torques effect the walking motion of a biped robot but the correlation would be convoluted for a beginner. The default choice of such a medium for control theory noobs is a linear time invariant (LTI) system. The next question would be what makes LTI systems special? Let’s start with some of its properties. A LTI system has three main properties: homogeneity, additivity (or commonly known as superposition) and as the name suggests time invariance. One may ask I see the time invariance, where is the linear? The “linear” part is constructed by the homogeneity and additivity. In the following sections we will look into these three properties.</summary></entry></feed>